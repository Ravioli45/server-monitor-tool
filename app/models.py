from datetime import datetime, timezone
from typing import List, Optional

from flask_login import UserMixin

import sqlalchemy as sa
import sqlalchemy.orm as so

from argon2.exceptions import VerificationError

from app import db
from app import ph
from app import login

"""
defines tables that are used in database

class definitions are turned into commands to create the tables using
flask migration (see autogenerated python scripts in migrations folder)
"""

# this tells flask-login how to get a user by id
# this is a simple query to the database
@login.user_loader
def load_user(id):
    return db.session.get(User, int(id))

# user class
#
# represents how user table will be setup by inheriting db.model
# represents user class for flask-login by inheriting UserMixin
class User(UserMixin, db.Model):
    id: so.Mapped[int] = so.mapped_column(primary_key=True)

    username: so.Mapped[str] = so.mapped_column(sa.String(64), index=True, unique=True)
    email: so.Mapped[str] = so.mapped_column(sa.String(64), index=True, unique=True)
    zip_key: so.Mapped[Optional[str]] = so.mapped_column(sa.String(64), nullable=True, default=lambda: None)

    # passwords are hashed and salted using argon2id
    # (argon2id stores the salt as part of the hash, hence no column for storing the salts used)
    password_hash: so.Mapped[str] = so.mapped_column(sa.String(256))

    # one to many relationship from User to Monitor
    monitors: so.WriteOnlyMapped[List['Monitor']] = so.relationship(
        back_populates="user",
        cascade="all, delete-orphan",
        passive_deletes=True
    )

    def set_password(self, password):
        self.password_hash = ph.hash(password)

    def check_password(self, password):
        try:
            return ph.verify(self.password_hash, password)
        except VerificationError:
            return False

    def __repr__(self):
        return f"<User {self.id}:{self.username}>"

# represents Monitor table in database by ineheriting db.Model
class Monitor(db.Model):
    id: so.Mapped[int] = so.mapped_column(primary_key=True)
    url: so.Mapped[str] = so.mapped_column(sa.String(512))

    time_next_ping: so.Mapped[datetime] = so.mapped_column(index=True)
    seconds_to_next_ping: so.Mapped[int] = so.mapped_column()

    # one to many from User to Monitor
    user_id: so.Mapped[int] = so.mapped_column(sa.ForeignKey(User.id, ondelete="CASCADE"), index=True)
    user: so.Mapped['User'] = so.relationship(back_populates="monitors")

    # one to many from Monitor to Status
    status_checks: so.WriteOnlyMapped[List['Status']] = so.relationship(
        back_populates="monitor",
        cascade="all, delete-orphan",
        passive_deletes=True
    )

    def __repr__(self):
        return f"<Monitor {self.id}:{self.url}>"

class Status(db.Model):
    id: so.Mapped[int] = so.mapped_column(primary_key=True)

    timestamp: so.Mapped[datetime] = so.mapped_column(index=True, default=lambda: datetime.now(timezone.utc))
    alerted: so.Mapped[bool] = so.mapped_column(index=True, default=lambda: False)

    response: so.Mapped[str] = so.mapped_column(sa.String(64))
    ssl_expired: so.Mapped[Optional[bool]] = so.mapped_column()

    # one to many from Monitor to Status
    monitor_id: so.Mapped[int] = so.mapped_column(sa.ForeignKey(Monitor.id, ondelete="CASCADE"), index=True)
    monitor: so.Mapped['Monitor'] = so.relationship(back_populates="status_checks")

    def __repr__(self):
        return f"<Status {self.id}:{self.response}>"
